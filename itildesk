#!/usr/bin/env perl

use Mojolicious::Lite;
use Time::HiRes qw(time);
use Clone 'clone';


########################################################################
### Create a New Game
########################################################################

our $_game;

# Create people seeded with random skill level
#
sub new_people {
  map { $_ => { skill => rand }}
  qw(
    Jack William Hiroto Ren Wei Jie Aarav Aaryan Jing Ying Aadhya Ananya
    Yuina Hina Ben Louis Emma Mia Charlotte Ruby Michelle Shane Nicholas
  )
}

# Create desks with abilities
#
sub new_desks {
  service => {
    action => {
      transfer => 1,
      identify => 1,
      request  => 'engineering',
      assign   => 1,
      handover => 'deploy',
    },
  },
  incident => {
    action => {
      transfer => 1,
      identify => 1,
      request  => 'incident',
      invent   => 1,
      breakfix => 1,
      pass     => 'problem',
    },
  },
  problem => {
    action => {
      transfer   => 1,
      identify   => 1,
      request    => 'engineering',
      workaround => 1,
      handover   => 'deploy',
    },
  },
  deploy => {
    action => {
      transfer => 1,
      apply    => 1,
    },
  },
  engineering => {
    action => {
      transfer => 1,
      assign   => 1,
    }
  },
  capacity => {
    action => {
      transfer  => 1,
      assign    => 1,
      increase  => 1,
      descrease => 1,
    }
  },
}

# Create issue seeded with difficulty and frequency
#
sub new_issue_types {
  map { $_ => { frequency => rand, difficulty => rand } }
   'Kernel Hung',
   'Disk Full',
   'User Cannot Login',
   'Package Outdated',
}

# Create type of issues seeded with difficulty and frequency
#
sub new_service_types {
  map { $_ => { frequency => rand, difficulty => rand } }
   'Hosting',
   'Decom',
   'Change',
}

# Create a new randomly seeded game
#
sub new_game {
  my %desks = new_desks();
  my %people = new_people();
  my @desknames = keys %desks;

  # Randomly distribute people to desks
  #
  while ( my($name,$attr) = each %people ) {
    # Random desk
    my $deskname = $desknames[rand @desknames];
    my $desk = $desks{$deskname};
    $desk->{person}{$name} = $attr;
  }

  # Catalog of solutions
  for my $desk ( values %desks ) {
    $desk->{solution} = {};
  }

  $_game->{desk} = \%desks;
  $_game->{issue_types} = { new_issue_types() };
  $_game->{service_types} = { new_service_types() };
  $_game->{updated} = time();
}


########################################################################
### Tickets
########################################################################

# Random title for a ticket
#
sub create_title {
  my @part = qw(all on some a just no again);
  my @adj  = qw(weird known expected spurious weak new old critical);
  my @comp = qw(issue error occurence invoke situation full);
  my @name = (sprintf "0x%s%s%s%s", map chr(64+32*rand), 1..4);
  my @dir  = qw(for on from with by);
  my @obj  = qw(user device disk cpu ram process network server nic kernel package password);

  return ucfirst join ' ', 
    $part[rand @part],
    $adj [rand @adj ],
    $comp[rand @comp],
    $name[rand @name],
    $dir [rand @dir ],
    $obj [rand @obj ],
}

# Add a new issue into a desk
#
our $_id_counter;
sub create_issue {
  my($deskname) = @_;

  # Pick ticket type based on frequency
  my $type = (
    map $_->[0],
    sort { $b->[1] <=> $a->[1] }
    map [ $_, $_game->{issue_types}{$_}{frequency}*rand ],
    keys %{$_game->{issue_types}}
  )[0];
  # Create ticket
  my $ticket = {
    title      => create_title(),
    request    => 'issue',
    solution   => $type,
    difficulty => $_game->{issue_types}{$type}{difficulty},
  };
  # Place ticket on desk
  $_game->{desk}{$deskname}{ticket}{++$_id_counter} = $ticket;
}

# Add a new issue into a desk
#
sub create_service {
  my($deskname) = @_;

  # Pick ticket based on frequency
  my $type = (
    map $_->[0],
    sort { $b->[1] <=> $a->[1] }
    map [ $_, $_game->{service_types}{$_}{frequency}*rand ],
    keys %{$_game->{service_types}}
  )[0];
  # Create ticket
  my $ticket = {
    request    => 'service',
    solution   => $type,
    difficulty => $_game->{service_types}{$type}{difficulty},
  };
  # Place ticket on desk
  $_game->{desk}{$deskname}{ticket}{++$_id_counter} = $ticket;
}


########################################################################
### Actions
########################################################################

# Pass a ticket into another queue
#
sub pass {
  my($deskname,$ticket_id) = @_;

  # Current desk
  my $curdesk = $_game->{desk}{$deskname};

  # Find new desk
  my $target_deskname = $curdesk->{action}{pass};
  return {error=>"$deskname desk cannot pass tickets"} unless $target_deskname;

  # Find ticket
  my $ticket = $curdesk->{ticket}{$ticket_id};
  return {error=>"Ticket $ticket_id is not on $deskname desk"} unless $ticket;

  # Remove current assignment and action
  if ( $ticket->{action} ) {
    for my $action ( keys %{$ticket->{action}} ) {
      if ( $ticket->{action}{$action}{status} eq 'active' ) {
        my $person_name = $ticket->{action}{$action}{person};
        delete $ticket->{action}{$action};
        delete $curdesk->{person}{$person_name}{ticket};
      }
    }
  }

  # Remove from desk
  delete $curdesk->{ticket}{$ticket_id};

  # Add to desk
  $_game->{desk}{$target_deskname}{ticket}{$ticket_id} = $ticket;
}

# Start identification of a ticket
#
sub identify {
  my($deskname, $person_name, $ticket_id) = @_;

  # Remove current assignment
  #
  #unassign($person_name,$ticket_id);

  # Confirm person and ticket on desk
  my $desk = $_game->{desk}{$deskname};
  return
    {error=>"Person $person_name and ticket $ticket_id not found on same desk"}
    unless my $person = $desk->{person}{$person_name}
       and my $ticket = $desk->{ticket}{$ticket_id};

  # Already identified or being identified
  if ( my $identify = $ticket->{action}{identify} ) {
    if ( $identify->{status} eq 'done') {
      return {error=>"Ticket $ticket_id already identified"};
    } elsif ( $identify->{person} eq $person_name ) {
      return {error=>"$person_name already identifying ticket $ticket_id"};
    } else {
      # Cancel work
      delete $desk->{person}{$person_name}{ticket};
      delete $ticket->{action}{identify};
    }
  }

  # Start identify action
  my $duration = 10 * $ticket->{difficulty} / $person->{skill};
  $ticket->{action}{identify} = {
    start  => time(),
    person => $person_name,
    status => 'active',
    end    => time()+$duration,
  };

  # Mark person as working
  $person->{ticket} = $ticket_id;
  return 'OK';
}

# Remove a ticket assignment (it may not exist in the first place
#
#sub unassign {
#  my($person_name,$ticket_id) = @_;
#
#  for my $desk ( values %{$_game->{desk}} ) {
#    delete $desk->{ticket}{$ticket_id}{person} 
#        if $desk->{ticket}{$ticket_id};
#    delete $desk->{person}{$person_name}{ticket}
#        if $desk->{person}{$person_name};
#  }
#}

# Whatever a person is working on, cancel it
#
sub cancel {
  my($person_name) = @_;

  #my($desk) = grep 
}


########################################################################
### Solutions
########################################################################

# Add solution to desk, or increase efficiency
#
sub enlist {
  my($deskname, $solutionname) = @_;

  my $desk = $_game->{desk}{$deskname};
  $desk->{solution}{$solutionname} ||= {};
  $desk->{solution}{$solutionname}{efficiency} += 0.1;
  $desk->{solution}{$solutionname}{efficiency} = 1
    if $desk->{solution}{$solutionname}{efficiency} > 1;
}


########################################################################
### Game Maintenance
########################################################################

# Maintenance before updating
#
sub turn {
  # Duration since last turn
  my $now = time();
  my $last = $_game->{updated};
  $_game->{updated} = $now;
  my $duration = $now - $last;

  # Change status to done for completed actions 
  for my $desk ( values %{$_game->{desk}} ) {
    next unless $desk->{ticket};
    for my $ticket ( values %{$desk->{ticket}} ) {
      next unless $ticket->{action};
      for my $action_name ( keys %{$ticket->{action}} ) {
        my $action = $ticket->{action}{$action_name};
        if ( $action->{status} eq 'active') {
          if ( $action->{end} < $now ) {
            $action->{status} = 'done';
            my $person_name = $action->{person};
            delete $desk->{person}{$person_name}{ticket};
            $ticket->{show_solution}=1 if $action_name eq 'identify';
          }
        }
      }
    }
  }

  # TODO People skill up or down
  # TODO Solution efficiency up or down

  # Game Score
  my $ticket_count = 0;
  $ticket_count += scalar map keys(%{$_->{ticket}}), values %{$_game->{desk}};
  $_game->{score} = 100 - $ticket_count;
}


########################################################################
### Web Server
########################################################################

app->secrets(['litedesk secret passphrase goes here']);

new_game();
create_issue('incident') for 1..5;
create_service('service') for 1..5;
pass('incident', 1);
enlist('incident', 'Kernel Hung') for 1..2;
identify('incident', (keys %{$_game->{desk}{incident}{person}})[0], '2') ;

post '/update' => sub {
  my $c = shift;

  turn();
  #for my $key ( qw(desk ticket pass) ) {
  #  if ( my $val = $c->param($key) ) {
  #    warn sprintf "*** %s=%s\n", $key, $val;
  #  }
  #}
  my $resp = {error => 'Missing data, nothing done'};
  if ( my $desk = $c->param('desk') ) {
    if ( my $ticket = $c->param('ticket') ) {
      if ( $c->param('pass') ) {
        $resp = pass( $desk, $ticket );
      }
      if ( my $person = $c->param('person') ) {
        if ( $c->param('identify') ) {
          $resp = identify($desk, $person, $ticket);
        }
      }
    }
  }
  
  $c->flash( error => $resp->{error} ) if ref $resp;
  $c->redirect_to($c->url_for('/'));
} => 'update';

get '/' => sub {
  my $c = shift;

  turn();
  $c->stash( game => clone $_game );
  $c->render(template => 'index');
} => 'índex';

app->start;
