#!/usr/bin/env perl

use Mojolicious::Lite;
use Time::HiRes qw(time);
use Clone 'clone';


########################################################################
### Create a New Game
########################################################################

our $_game;

# Create people seeded with random skill level
#
sub new_people {
  map { $_ => { skill => rand }}
  qw(
    Jack William Hiroto Ren Wei Jie Aarav Aaryan Jing Ying Aadhya Ananya
    Yuina Hina Ben Louis Emma Mia Charlotte Ruby Michelle Shane Nicholas
  )
}

# Create desks with abilities
#
sub new_desks {
  service => {
    action => {
      transfer => 1,
      identify => 1,
      request  => 'engineering',
      assign   => 1,
      handover => 'deploy',
    },
  },
  incident => {
    action => {
      transfer => 1,
      identify => 1,
      request  => 'incident',
      invent   => 1,
      breakfix => 1,
      pass     => 'problem',
    },
  },
  problem => {
    action => {
      transfer   => 1,
      identify   => 1,
      request    => 'engineering',
      workaround => 1,
      handover   => 'deploy',
    },
  },
  deploy => {
    action => {
      transfer => 1,
      apply    => 1,
    },
  },
  engineering => {
    action => {
      transfer => 1,
      invent   => 1,
    }
  },
  #capacity => {
  #  action => {
  #    transfer  => 1,
  #    assign    => 1,
  #    increase  => 1,
  #    descrease => 1,
  #  }
  #},
}

# Create issue seeded with difficulty and frequency
#
sub new_issue_types {
  map { $_ => { frequency => rand, difficulty => rand } }
   'Kernel Hung',
   'Disk Full',
   'User Cannot Login',
   'Package Outdated',
}

# Create type of issues seeded with difficulty and frequency
#
sub new_service_types {
  map { $_ => { frequency => rand, difficulty => rand } }
   'Hosting',
   'Decom',
   'Change',
}

# Create a new randomly seeded game
#
sub new_game {
  my %desks = new_desks();
  my %people = new_people();
  my @desknames = keys %desks;

  # Randomly distribute people to desks
  #
  while ( my($name,$attr) = each %people ) {
    # Random desk
    my $deskname = $desknames[rand @desknames];
    my $desk = $desks{$deskname};
    $desk->{person}{$name} = $attr;
  }

  # Catalog of solutions
  for my $desk ( values %desks ) {
    $desk->{solution} = {};
  }

  $_game->{desk} = \%desks;
  $_game->{issue_types} = { new_issue_types() };
  $_game->{service_types} = { new_service_types() };
  $_game->{updated} = time();
}


########################################################################
### Tickets
########################################################################

# Random title for a ticket
#
sub create_title {
  my @part = qw(all on some a just no again this that one two);
  my @adj  = qw(weird known expected spurious weak new old critical);
  my @comp = qw(issue error occurence invoke situation full start stop panic
                loss flop flip flap flup recover click tick drop drag);
  my @name = (join '', '0x', map chr(63+32*rand), 0..rand(8));
  my @dir  = qw(for on from with by);
  my @obj  = qw(user device disk cpu ram process network server nic kernel
                package password buffer start end mouse account cable connect
                swap keyboard version);

  return ucfirst join ' ', 
    $part[rand @part],
    $adj [rand @adj ],
    $comp[rand @comp],
    $name[rand @name],
    $dir [rand @dir ],
    $obj [rand @obj ],
}

# Add a ticket to a desk
#
our $_id_counter;
sub add_ticket {
  my($deskname, $ticket) = @_;

  # Place ticket on desk
  $_game->{desk}{$deskname}{ticket}{++$_id_counter} = $ticket;
}

# Add a new issue into a desk
#
sub create_issue {
  my($deskname) = @_;

  # Pick ticket type based on frequency
  my $solution = (
    map $_->[0],
    sort { $b->[1] <=> $a->[1] }
    map [ $_, $_game->{issue_types}{$_}{frequency}*rand ],
    keys %{$_game->{issue_types}}
  )[0];

  # Don't create tickets for which workarounds exists
  return { error=>"Workaround in place for issue type $solution" }
    if $_game->{workaround}{$solution};

  # Create ticket
  my $ticket = {
    title      => create_title(),
    request    => 'issue',
    solution   => $solution,
    difficulty => $_game->{issue_types}{$solution}{difficulty},
  };
  # Place ticket on desk
  add_ticket( $deskname, $ticket );
}

# Add a new issue into a desk
#
sub create_service {
  my($deskname) = @_;

  # Pick ticket based on frequency
  my $type = (
    map $_->[0],
    sort { $b->[1] <=> $a->[1] }
    map [ $_, $_game->{service_types}{$_}{frequency}*rand ],
    keys %{$_game->{service_types}}
  )[0];
  # Create ticket
  my $ticket = {
    title      => create_title(),
    request    => 'service',
    solution   => $type,
    difficulty => $_game->{service_types}{$type}{difficulty},
  };
  # Place ticket on desk
  add_ticket( $deskname, $ticket );
}

########################################################################
### Start, cancel, complete actions
########################################################################

# Attempt to cancel an unfinished action
#
sub cancel_action {
  my($desk,$ticket,$action_name) = @_;

  my $person_name = $ticket->{action}{$action_name}{person};
  delete $desk->{person}{$person_name}{$ticket};
  delete $ticket->{action}{$action_name};
  delete $ticket->{doing};
}

# Try to start action. There may be a number of reson for why cannot
#
sub start_action {
  my($desk,$person_name,$ticket_id,$action_name,$duration) = @_;

  # Action in progress or completed?
  my $ticket = $desk->{ticket}{$ticket_id};
  my $person = $desk->{person}{$person_name};
  if ( my $action = $ticket->{action}{$action_name} ) {
    if ( $action->{status} eq 'done') {
      # Already done
      return {error=>"Ticket $ticket_id action $action_name already done"};
    } elsif ( $action->{person} eq $person_name ) {
      # Continue with same person
      return {error=>"$person_name already doing $action_name on ticket $ticket_id"};
    }
    # Cancel work for previous person
    cancel_action($desk, $ticket, $action_name);
  }

  # Start action
  $ticket->{action}{$action_name} = {
    start  => time(),
    person => $person_name,
    status => 'active',
    end    => time()+$duration,
  };
  $ticket->{doing} = $action_name;
  $person->{ticket} = $ticket_id;

  return { error=>"$person_name is doing $action_name on ticket $ticket_id"};
}

# Complete an action when it's done
#
sub complete_action {
  my($desk,$ticket_id,$action_name) = @_;

  # Action exists?
  return { error=>"No $action_name action in ticket $ticket_id" }
    unless my $ticket = $desk->{ticket}{$ticket_id}
       and my $action = $desk->{ticket}{$ticket_id}{action}{$action_name};

  # Even in progress?
  return { error=>"Action $action_name not active" }
    if $action->{status} ne 'active';

  # Still in progress?
  return { error=>"Action $action_name still in progress" }
    if $action->{end} > time();

  # Free up person
  my $person_name = $action->{person};
  my $person = $desk->{person}{$person_name};
  delete $person->{ticket};

  # Mark as done
  $action->{status} = 'done';
  delete $ticket->{doing};

  # Post action changes
  if ( $action_name eq 'identify' ) {
    $ticket->{show_solution} = 1;
  } elsif ( $action_name eq 'breakfix' ) {
    delete $desk->{ticket}{$ticket_id};
  } elsif ( $action_name eq 'workaround' ) {
    delete $desk->{ticket}{$ticket_id};
    $desk->{workaround}{$ticket->{solution}} = 1;
  } elsif ( $action_name eq 'apply' ) {
    delete $desk->{ticket}{$ticket_id};
    $desk->{apply}{$ticket->{solution}} = 1;
    # TODO Delete all ticket of this solution
  } elsif ( $action_name eq 'invent' ) {
    my $deskname = $ticket->{desk};
    enlist( $ticket->{desk}, $ticket->{solution} );
    delete $desk->{ticket}{$ticket_id};
  }

  #return { error=>"$action_name completed" };
}


########################################################################
### Request to initiate Actions
########################################################################

# Confirm desk can action, has person and has ticket
#
sub desk_has_can {
  my($deskname, $person_name, $ticket_id, $action_name) = @_;

  my($person,$ticket,$target);
  # Confirm desk exist
  return { error=>"$deskname is not a valid desk" }
    unless my $desk = $_game->{desk}{$deskname};

  # Confirm desk can do action
  if ( length $action_name ) {
    return
      { error=>"$deskname desk cannot do $action_name" }
      unless $target = $desk->{action}{$action_name};
  }

  # Confirm person on desk
  if ( length $person_name ) {
    return
      { error=>"$person_name not found on $deskname desk"}
      unless $person = $desk->{person}{$person_name};
  }

  # Confirm ticket on desk
  if ( length $ticket_id ) {
    return
      { error=>"Ticket $ticket_id not found on $deskname desk"}
      unless $ticket = $desk->{ticket}{$ticket_id};
  }

  return( $desk, $person, $ticket, $target );
}

# Kick a person over to different random desk
#
sub transfer {
  my($deskname,$person_name) = @_;

  my($desk,$person,$ticket,$target) = 
    desk_has_can($deskname, $person_name, undef, 'transfer');
  return $desk if $desk->{error};

  # Stop whatever person is working on
  if ( my $ticket_id = $person->{ticket} ) {
    my $ticket = $desk->{ticket}{$ticket_id};
    my $action_name = $ticket->{doing};
    cancel_action($desk,$ticket,$action_name);
  }

  # Skill decrease when moving
  $person->{skill} /= 2;

  # Pick random other desk
  my($newdeskname) =
    sort { rand() <=> rand() }
    grep { $_ ne $deskname }
    keys %{$_game->{desk}};
  my $newdesk = $_game->{desk}{$newdeskname};

  # Complete the transfer
  delete $desk->{person}{$person_name};
  $newdesk->{person}{$person_name} = $person;
  return { error=>"Transfered $person_name from $deskname to $newdeskname" };
}

# Pass a ticket into another queue
#
sub pass {
  my($deskname,$ticket_id) = @_;

  my($desk,$person,$ticket,$target) = 
    desk_has_can($deskname, undef, $ticket_id, 'pass');
  return $desk if $desk->{error};

  # Verify that identification is completed
  return { error=>"Cannot pass ticket $ticket_id without identification" }
    unless $ticket->{show_solution};

  # Remove current assignment and action
  if ( my $action_name = $ticket->{doing} ) {
    cancel_action($desk, $ticket, $action_name);
  }

  # Complete ticket transfer
  delete $desk->{ticket}{$ticket_id};
  $_game->{desk}{$target}{ticket}{$ticket_id} = $ticket;
  return { error=>"Transfered ticket $ticket_id from $deskname to $target" };
}

# Create a request to create solution
#
sub request {
  my($deskname,$ticket_id) = @_;

  my($desk,$person,$ticket,$target) = 
    desk_has_can($deskname, undef, $ticket_id, 'request');
  return $desk if $desk->{error};

  # Confirm ticket is identified
  return {error=>"Ticket $ticket_id is not identified"}
    unless $ticket->{show_solution};

  # Spawn ticket to target team
  my $solution = $ticket->{solution};
  my $request = {
    title      => "Invent $solution for $deskname",
    request    => 'invent',
    desk       => $deskname,
    solution   => $solution,
    difficulty => $_game->{issue_types}{$solution}{difficulty},
  };

  add_ticket($target, $request);
  return {error=>"Requested $target to invent solution for $solution"};
}

# Start identification of a ticket
#
sub identify {
  my($deskname, $person_name, $ticket_id) = @_;

  my($desk,$person,$ticket,$target) = 
    desk_has_can($deskname, $person_name, $ticket_id, 'identify');
  return $desk if $desk->{error};

  my $duration = 10 * $ticket->{difficulty} / $person->{skill};
  start_action($desk, $person_name, $ticket_id, 'identify', $duration);
}

# Breakfix, workaround and apply all start the same. The end is different.
#
sub ticket_resolution {
  my($deskname, $person_name, $ticket_id, $solution, $action_name) = @_;

  my($desk,$person,$ticket,$target) = 
    desk_has_can($deskname, $person_name, $ticket_id, $action_name);
  return $desk if $desk->{error};

  # Confirm ticket is identified
  return {error=>"Ticket $ticket_id is not identified"}
    unless $ticket->{show_solution};

  # Confirm that operator picked correct solution
  return { error=>"$solution is wrong solution for ticket $ticket_id"}
    if $solution ne $ticket->{solution};

  # Calculate resolution time
  my $efficiency = $desk->{solution}{$solution}{efficiency};
  my $duration = 10 * $ticket->{difficulty} / ( $person->{skill} * $efficiency );

  # Start work
  start_action($desk, $person_name, $ticket_id, $action_name, $duration);
}

# Start invention of solution
#
sub invent {
  my($deskname,$person_name,$ticket_id) = @_;

  my($desk,$person,$ticket,$target) = 
    desk_has_can($deskname, $person_name, $ticket_id, 'invent');
  return $desk if $desk->{error};

  # Confirm ticket is invention request
  return
    {error=>"Ticket $ticket_id is not request for invention"}
    unless $ticket->{request} eq 'invent';
  my $solution = $ticket->{solution};

  # Start work
  my $duration = 10 * $ticket->{difficulty} / $person->{skill};
  start_action($desk, $person_name, $ticket_id, 'invent', $duration);
}


########################################################################
### Solutions
########################################################################

# Add solution to desk, or increase efficiency when solution already exists
#
sub enlist {
  my($deskname, $solutionname) = @_;

  my $desk = $_game->{desk}{$deskname};
  $desk->{solution}{$solutionname} ||= {};
  $desk->{solution}{$solutionname}{efficiency} += 0.1;
  $desk->{solution}{$solutionname}{efficiency} = 1
    if $desk->{solution}{$solutionname}{efficiency} > 1;
}


########################################################################
### Game Maintenance
########################################################################

# Maintenance before updating
#
sub turn {
  # Duration since last turn
  my $now = time();
  my $last = $_game->{updated};
  $_game->{updated} = $now;
  my $duration = $now - $last;

  # Check for completed actions
  for my $desk ( values %{$_game->{desk}} ) {
    next unless $desk->{ticket};
    for my $ticket_id ( keys %{$desk->{ticket}} ) {
      my $ticket = $desk->{ticket}{$ticket_id};
      next unless $ticket->{action};
      for my $action_name ( keys %{$ticket->{action}} ) {
       complete_action($desk, $ticket_id, $action_name);
      }
    }
  }

  # TODO People skill up or down
  # TODO Solution efficiency up or down

  # Game Score
  my $ticket_count = 0;
  $ticket_count += scalar map keys(%{$_->{ticket}}), values %{$_game->{desk}};
  $_game->{score} = 100 - $ticket_count;
}


########################################################################
### Web Server
########################################################################

app->secrets(['litedesk secret passphrase goes here']);

new_game();
create_issue('incident') for 1..5;
create_service('service') for 1..5;
pass('incident', 1);
enlist('incident', 'Kernel Hung') for 1..2;
identify('incident', (keys %{$_game->{desk}{incident}{person}})[0], '2') ;

post '/update' => sub {
  my $c = shift;

  turn();
  for my $key ( qw(apply desk ticket person solution breakfix handover identify invent pass request transfer workaround) ) {
    if ( my $val = $c->param($key) ) {
      warn sprintf "*** POST %s=%s\n", $key, $val;
    }
  }
  my $resp = {error => 'Missing data, nothing done'};
  if ( my $desk = $c->param('desk') ) {
    if ( my $ticket = $c->param('ticket') ) {
      if ( $c->param('pass') ) {
        $resp = pass( $desk, $ticket );
      }
      if ( $c->param('request') ) {
        $resp = request( $desk, $ticket );
      }
      if ( my $person = $c->param('person') ) {
        if ( $c->param('identify') ) {
          $resp = identify($desk, $person, $ticket);
        }
        if ( $c->param('invent') ) {
          $resp = invent($desk, $person, $ticket);
        }
        if ( $c->param('breakfix') and my $solution = $c->param('solution') ) {
          $resp = ticket_resolution($desk, $person, $ticket, $solution, 'breakfix');
        }
        if ( $c->param('workaround') and my $solution = $c->param('solution') ) {
          $resp = ticket_resolution($desk, $person, $ticket, $solution, 'workaround');
        }
      }
    } elsif ( my $person = $c->param('person') ) {
      if ( $c->param('transfer') ) {
        $resp = transfer($desk, $person);
      }
    }
  }
  
  $c->flash( error => $resp->{error} ) if ref $resp;
  $c->redirect_to($c->url_for('/'));
} => 'update';

get '/' => sub {
  my $c = shift;

  turn();
  $c->stash( game => clone $_game );
  $c->render(template => 'index');
} => 'índex';

app->start;
