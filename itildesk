#!/usr/bin/env perl

use Mojolicious::Lite;
use Time::HiRes qw(time);

########################################################################
### Create a New Game
########################################################################

our $_game;

# Create people seeded with random skill level
#
sub new_people {
  map { $_ => { skill => rand }}
  qw(
    Jack William Hiroto Ren Wei Jie Aarav Aaryan Jing Ying Aadhya Ananya
    Yuina Hina Ben Louis Emma Mia Charlotte Ruby Michelle Shane Nicholas
  )
}

# Create desks with abilities
#
sub new_desks {
  service => {
    action => {
      identify => 1,
      request  => 'engineering',
      assign   => 1,
      handover => 'deploy',
    },
  },
  incident => {
    action => {
      identify => 1,
      request  => 'incident',
      invent   => 1,
      breakfix => 1,
      pass     => 'problem',
    },
  },
  problem => {
    action => {
      identify   => 1,
      request    => 'engineering',
      workaround => 1,
      handover   => 'deploy',
    },
  },
  deploy => {
    action => {
      apply => 1,
    },
  },
  engineering => {
    action => {
      assign => 1,
    }
  },
}

# Create issue seeded with difficulty and frequency
#
sub new_issue_types {
  map { $_ => { frequency => rand, difficulty => rand } }
   'Kernel Hung',
   'Disk Full',
   'User Cannot Login',
   'Package Outdated',
}

# Create type of issues seeded with difficulty and frequency
#
sub new_service_types {
  map { $_ => { frequency => rand, difficulty => rand } }
   'Hosting',
   'Decom',
   'Change',
}

# Create a new randomly seeded game
#
sub new_game {
  my %desks = new_desks();
  my %people = new_people();
  my @desknames = keys %desks;

  # Randomly distribute people to desks
  #
  while ( my($name,$attr) = each %people ) {
    # Random desk
    my $deskname = $desknames[rand @desknames];
    my $desk = $desks{$deskname};
    $desk->{person}{$name} = $attr;
  }

  # Catalog of solutions
  for my $desk ( values %desks ) {
    $desk->{solution} = {};
  }

  $_game->{desk} = \%desks;
  $_game->{issue_types} = { new_issue_types() };
  $_game->{service_types} = { new_service_types() };
}

########################################################################
### Tickets
########################################################################

# Add a new issue into a desk
#
our $_id_counter;
sub create_issue {
  my($deskname) = @_;

  # Pick ticket type based on frequency
  my $type = (
    map $_->[0],
    sort { $b->[1] <=> $a->[1] }
    map [ $_, $_game->{issue_types}{$_}{frequency}*rand ],
    keys %{$_game->{issue_types}}
  )[0];
  # Create ticket
  my $ticket = {
    request    => 'issue',
    solution   => $type,
    difficulty => $_game->{issue_types}{$type}{difficulty},
  };
  # Place ticket on desk
  $_game->{desk}{$deskname}{ticket}{++$_id_counter} = $ticket;
}

# Add a new issue into a desk
#
sub create_service {
  my($deskname) = @_;

  # Pick ticket based on frequency
  my $type = (
    map $_->[0],
    sort { $b->[1] <=> $a->[1] }
    map [ $_, $_game->{service_types}{$_}{frequency}*rand ],
    keys %{$_game->{service_types}}
  )[0];
  # Create ticket
  my $ticket = {
    request    => 'service',
    solution   => $type,
    difficulty => $_game->{service_types}{$type}{difficulty},
  };
  # Place ticket on desk
  $_game->{desk}{$deskname}{ticket}{++$_id_counter} = $ticket;
}

# Pass a ticket into another queue
#
sub pass {
  my($deskname,$ticket_id) = @_;

  # Find new desk
  my $target_deskname = $_game->{desk}{$deskname}{action}{pass};
  return {error=>"$deskname desk cannot pass tickets"} unless $target_deskname;

  # Find ticket
  my $ticket = $_game->{desk}{$deskname}{ticket}{$ticket_id};
  return {error=>"Ticket $ticket_id is not on $deskname desk"} unless $ticket;

  # Remove current assignment TODO

  # Remove from desk
  delete $_game->{desk}{$deskname}{ticket}{$ticket_id};

  # Add to desk
  $_game->{desk}{$target_deskname}{ticket}{$ticket_id} = $ticket;
}


########################################################################
### Assignments Ticket/Person
########################################################################

# Assign ticket to person and vice versa
#
sub start {
  my($action,$person_name,$ticket_id) = @_;

  # Remove current assignment
  #
  #unassign($person_name,$ticket_id);

  # Find correct desk
  for my $desk ( values %{$_game->{desk}} ) {
    next unless my $person = $desk->{person}{$person_name}
            and my $ticket = $desk->{ticket}{$ticket_id};
    #$desk->{person}{$person_name}{ticket} = $desk->{ticket}{$ticket_id};
    #$desk->{ticket}{$ticket_id}{person} = $desk->{person}{$person_name};
    # XXX consider solution efficiency
    my $duration = 10 * $ticket->{difficulty} / $person->{skill};
    $ticket->{action}{$action} = {
      start => time(),
      person => $person_name,
      status => 'active',
      end => time()+$duration,
    };

    $person->{ticket} = $ticket_id;
    
    return;
  }
  return {error=>"Person $person_name and ticket $ticket_id not found on same desk"};
}

# Remove a ticket assignment (it may not exist in the first place
#
#sub unassign {
#  my($person_name,$ticket_id) = @_;
#
#  for my $desk ( values %{$_game->{desk}} ) {
#    delete $desk->{ticket}{$ticket_id}{person} 
#        if $desk->{ticket}{$ticket_id};
#    delete $desk->{person}{$person_name}{ticket}
#        if $desk->{person}{$person_name};
#  }
#}


########################################################################
### Solutions
########################################################################

# Add solution to desk, or increase efficiency
#
sub enlist {
  my($deskname, $solutionname) = @_;

  my $desk = $_game->{desk}{$deskname};
  $desk->{solution}{$solutionname} ||= {};
  $desk->{solution}{$solutionname}{efficiency} += 0.1;
  $desk->{solution}{$solutionname}{efficiency} = 1
    if $desk->{solution}{$solutionname}{efficiency} > 1;
}


########################################################################
### Game Maintenance
########################################################################

# Maintenance before updating
#
sub turn {
  # Change status to done for completed actions 
  for my $desk ( values %{$_game->{desk}} ) {
    for my $ticket ( values %{$desk->{ticket}} ) {
      for my $action ( values %{$ticket->{action}} ) {
        if ( $action->{status} eq 'active') {
          if ( $action->{end} < time() ) {
            $action->{status} = 'done';
            my $person_name = $action->{person};
            delete $desk->{person}{$person_name}{ticket};
          }
        }
      }
    }
  }
}


########################################################################
### Web Server
########################################################################

app->secrets(['litedesk secret passphrase goes here']);

new_game();
create_issue('incident') for 1..5;
create_service('service') for 1..5;
pass('incident', 1);
enlist('incident', 'Kernel Hung') for 1..2;
start('identify',(keys %{$_game->{desk}{incident}{person}})[0], '2') ;

post '/update' => sub {
  my $c = shift;

   turn();
   #for my $key ( qw(desk ticket pass) ) {
   #  if ( my $val = $c->param($key) ) {
   #    warn sprintf "*** %s=%s\n", $key, $val;
   #  }
   #}
   if ( $c->param('pass') ) {
     my $resp = pass( $c->param('desk'), $c->param('ticket') );
     $c->flash( error => $resp->{error} ) if ref $resp;
   }
   $c->redirect_to($c->url_for('/'));
} => 'update';

get '/' => sub {
  my $c = shift;

  turn();
  $c->stash( game => $_game );
  $c->render(template => 'index');
} => 'Ã­ndex';

app->start;
